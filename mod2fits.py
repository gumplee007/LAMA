#%%
# the function of this code is reading a set of the binary file of the templates and writing to a fits file
# import the offical module
import numpy as np
import pandas as pd
from astropy.io import fits
from scipy.ndimage import gaussian_filter1d
from tqdm import tqdm
import time

# import private module
from norm import norm
from air2vac import air2vac

#%%
def deres(wl, flux, res_h, res_l):
    '''
    decrease the resolution of spectrum
    wl, flux: the wavelength and flux of a spectrum
    res_h, res_l: the original or higher resolution and the target or lower resolution
    output: the flux decreased to the lower resolution
    '''
    lambda0 = np.mean(wl)
    D_lambda = np.mean(np.diff(wl))
    k = lambda0/D_lambda/res_h
    sigma = k * np.sqrt(res_h**2 - res_l**2)/2.355/res_l
    return gaussian_filter1d(flux, sigma, mode = 'reflect')

#%%
# read the list of the templates contains the stellar parameters and the binary file names of the templates
# the file which contains the information of the templates is a csv file
d = pd.read_csv('templates.csv')
# convert the series to numpy array
Teff = d['Teff'].to_numpy()
logg = d['logg'].to_numpy()
Feh = d['Feh'].to_numpy()

# # select the parameters range of the templates
# index_Teff = np.in1d(Teff, np.arange(3600, 13000, 200))
# index_logg = np.in1d(logg, np.around(np.arange(0, 6.1, 0.5), 1))
# index_Feh = (Feh >= -5.0)
# index_grid = index_Teff & index_logg & index_Feh
index_grid = (Teff >= 0)
pars = np.transpose([Teff[index_grid], logg[index_grid], Feh[index_grid]])
dd = d[index_grid].reset_index()

#%%
# read the wavelength of the template from a binary file
wln = np.loadtxt(d['filename'].iloc[0], usecols = (0), unpack = True)
# if the wavelength of the template is in air, convert it to vaccum
wln = air2vac(wln)
# define the blue and red arm spectrum
index_b = (wln < 6000)
index_r = (wln > 6000)
# read the wavelength of the template from a binary file
wl = np.loadtxt('wavelength.dat', usecols = (0), unpack = True)
# set the wavelength array
wl_b = np.arange(4850, 5350, 0.1)
wl_r = np.arange(6300, 6800, 0.1)


#%%
Flux = []
Flux_B = []
Flux_R = []
for i in tqdm(range(len(dd))):
    # read the flux of the template
    fluxb = np.loadtxt(dd['filename'].iloc[i][:-4], usecols = (0), unpack = True)
    fluxr = np.loadtxt(dd['filename'].iloc[i][:-4], usecols = (1), unpack = True)
    # # decrease the resolution if you want
    # flux_25000_b = deres(wln[index_b], flux[index_b], 5150/0.02, 25000)
    # flux_25000_r = deres(wln[index_r], flux[index_r], 6600/0.02, 25000)
    # interpolate template to the wavelength array
    Flux_B.append(np.interp(wl_b, wln[index_b], fluxb[index_b]))
    Flux_R.append(np.interp(wl_r, wln[index_r], fluxr[index_r]))


#%%
# make header, this is not necessary
hdr = fits.Header()
hdr['Atomsphe'] = ('Kurucz', 'Model Atomspheres')
hdr['Res'] = (25000, 'Resolution')
hdr['Norm'] = (True, 'If the spectra are normalized')
hdr['DLAMBDA'] = (0.1, 'Step of wavelength (Angstrom)')

hdr['exten0'] = 'Teff, logg, Feh'
hdr['exten1'] = 'Wavelength of Blue Arms'
hdr['exten2'] = 'Nomalized Flux of Blue Arms'
hdr['exten3'] = 'Wavelength of Red Arms'
hdr['exten4'] = 'Normalized Flux of Red Arms'

hdr.add_comment(' -------- Grid of Normalized Stellar Atomsphere Model Spetra')
current_time=time.strftime("%Y-%b-%d %a %H:%M:%S", time.localtime())
hdr.add_comment(' -------- Generated by Li Chunqian at ' + current_time)
hdr.add_comment(' -------- lcq@nao.cas.cn')

#%%
# write the data to the fits file
hdu0 = fits.PrimaryHDU(data = pars, header = hdr)
hdu1 = fits.ImageHDU(data = wl_b)
hdu2 = fits.ImageHDU(data = Flux_B)
hdu3 = fits.ImageHDU(data = wl_r)
hdu4 = fits.ImageHDU(data = Flux_R)
hdul = fits.HDUList([hdu0, hdu1, hdu2, hdu3, hdu4])
hdul.writeto('test.fits', overwrite = True)

#%%
